using System;
using System.Collections.Generic;
using System.ComponentModel;
using Eco.Core.Items;
using Eco.Gameplay.Blocks;
using Eco.Gameplay.Components;
using Eco.Gameplay.Components.Auth;
using Eco.Gameplay.DynamicValues;
using Eco.Gameplay.Economy;
using Eco.Gameplay.Housing;
using Eco.Gameplay.Interactions;
using Eco.Gameplay.Items;
using Eco.Gameplay.Modules;
using Eco.Gameplay.Minimap;
using Eco.Gameplay.Objects;
using Eco.Gameplay.Occupancy;
using Eco.Gameplay.Players;
using Eco.Gameplay.Property;
using Eco.Gameplay.Skills;
using Eco.Gameplay.Systems;
using Eco.Gameplay.Systems.TextLinks;
using Eco.Gameplay.Pipes.LiquidComponents;
using Eco.Gameplay.Pipes.Gases;
using Eco.Shared;
using Eco.Shared.Math;
using Eco.Shared.Localization;
using Eco.Shared.Serialization;
using Eco.Shared.Utils;
using Eco.Shared.View;
using Eco.Shared.Items;
using Eco.Shared.Networking;
using Eco.Gameplay.Pipes;
using Eco.World.Blocks;
using Eco.Gameplay.Housing.PropertyValues;
using Eco.Gameplay.Civics.Objects;
using Eco.Gameplay.Settlements;
using Eco.Gameplay.Systems.NewTooltip;
using Eco.Core.Controller;
using Eco.Core.Utils;
using Eco.Gameplay.Components.Storage;
using Eco.Gameplay.Items.Recipes;
using Eco.Mods.TechTree;
using Digits.PartSlotting;
using Eco.Gameplay.Wires;
using Eco.Gameplay.Civics.Elections;
using System.Reflection;
using Digits.Maintenance;
using Eco.Shared.IoC;
using Eco.World;

namespace Digits.Nuclear
{
    [Serialized]
    [LocDescription("Provides information about the reactor"), CreateComponentTabLoc("Reactor", true)]
    [RequireComponent(typeof(StatusComponent))]
    [RequireComponent(typeof(ReactorFuelComponent))]
    [RequireComponent(typeof(PartSlotComponent))]

    [RequireComponent(typeof(DigiCustomLiquidConverterComponent))]
    [AutogenClass]

    public class AdvancedReactorComponent : WorldObjectComponent, IController
    {
        //state variables
        bool hasFuel = false;
        float targetNeutronRate = 0;
        bool steadyState = true;

        //thermal constant variables
        float neutronAbsorbtionHeat = 1f; //amount of heat generated by a neutron being absorbed by moderator
        float temperatureAbsorbedBySteam = 100f;  //amount of heat taken away from the casing by converting 1 water to 1 steam
        float coreCasingTC = 100f;      //core -> casing thermal conductance (NOTE this is NOT CONDUCTIVITY)
        float casingEnvTC = 1f;      //casing -> enviroment thermal conductance (waste heat to enviroment)
        float coreHeatCapcity = 2000;
        float casingHeatCapcity = 10000;  

        //thermal state variables
        float coreTemperature => this.coreHeat / this.coreHeatCapcity;      //temperature of the reactor core (the fuel and moderator)
        float casingTemperature => this.casingHeat / this.casingHeatCapcity;    //temperature of the reactor casing (the coolant heat exchanger)
        float coreHeat = 0;
        float casingHeat = 0;

        //nuclear constant variables
        float T_neutron = 0.1f;         //average neutron lifetime 
        float P_impact = 0.5f;          //probability of neutron impact with fissionable material
        float P_fission = 0.25f;        //probability of fission event after impact
        float n_avg = 3;                //average number of neutrons released per fission event
        float P_absorbed = 0.2f;        //probability of neutrons being absorbed by moderator
        float P_escape = 0.1f;          //probability of neutrons escaping the reactor
        float fuelNeutronEmmision = 500;  //base neutron emmisions from fuel (through decay or other methods)

        //nuclear state variables
        float freeNeutrons = 0;         //tracks number of free neutrons within the reactor


        List<float> coolingQueue = new List<float>();

        StatusElement status;

        //average neutron lifetime is controled by moderator and reactor design
        //P_escape reactor design
        //P_absorb by moderator and control rod
        //P_impact controlled by reactor design and moderator
        //P_fission controlled by fuel and moderator
        //n_avg controlled by fuel

        public AdvancedReactorComponent()
        {
            this.targetNeutronRate = 0;
            this.steadyState = true;

            this.coreHeat = 20 * this.coreHeatCapcity;
            this.casingHeat = 20 * this.casingHeatCapcity;
            this.freeNeutrons = 0;
            this.fuelNeutronEmmision = 0;
        }

        public void Initialize(BlockOccupancyType inputBlockType, BlockOccupancyType outputBlockType)
        {
            DigiCustomLiquidConverterComponent LCcomp = this.Parent.GetComponent<DigiCustomLiquidConverterComponent>();
            LCcomp.Setup(typeof(WaterItem), typeof(SteamItem), inputBlockType, outputBlockType);
            LCcomp.OnConvert += OnConvert;
            LCcomp.ShouldConvertLiquid += CanConvert;

            this.status = this.Parent.GetComponent<StatusComponent>().CreateStatusElement();
        }

        public void OnConvert(float amount)
        {
            this.coolingQueue.Add(amount * temperatureAbsorbedBySteam);
        }

        public bool CanConvert()
        {
            if (this.casingTemperature > 100)
            {
                return true;
            }
            return false;
        }

        public override void Tick()
        {
            UpdateReactorDynamics();
            LocString statusMsg = Localizer.Format("{0}, {1}, {2}", Text.Info(this.coreTemperature), Text.Info(this.casingTemperature), Text.Info(this.freeNeutrons));
            this.status.SetStatusMessage(true, statusMsg);

            Type type = typeof(WireConnection);
            FieldInfo fieldInfo = type.GetField("<WireRefs>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance);

            ThreadSafeList<WeakReference<WireConnection>> value = (ThreadSafeList < WeakReference < WireConnection >> ) fieldInfo.GetValue(this.Parent.GetComponent<DigiCustomLiquidConverterComponent>().producer.OutputPipe);

            if (value is ThreadSafeList<WeakReference<WireConnection>> threadSafeList)
            {
                foreach (var thing in threadSafeList.Refs())
                {
                    thing.Owner.GetComponent<TurbineComponent>().temperature = 1000;
                    Log.Write(Localizer.Format(thing.Owner.ToString()));
                }
            }    
        }

        private float CalculateControlRodInsertion(float targetNeutronRate, float currentNeutrons)
        {
            if (currentNeutrons == 0) currentNeutrons = 1;

            float alpha = ((targetNeutronRate - this.fuelNeutronEmmision) * this.T_neutron) / currentNeutrons;
            float rodInsertion = 1 - ((alpha + this.P_escape + this.P_absorbed) / (this.P_fission * this.n_avg * this.P_impact));


            if (rodInsertion < 0) rodInsertion = 0;
            else if (rodInsertion > 1) rodInsertion = 1;

            if (targetNeutronRate == 0) this.steadyState = true;
            else this.steadyState = false;

            return rodInsertion;
        }

        private float CalculateFreeNeutronRate(float freeNeutrons, float P_adj)
        {
            float alpha;
            float freeNeutronsRate;

            alpha = ((this.P_fission * (this.P_impact * P_adj) * this.n_avg) - this.P_absorbed) - this.P_escape;
            freeNeutronsRate = ((alpha * freeNeutrons) / T_neutron) + this.fuelNeutronEmmision;

            return freeNeutronsRate ;
        }

        private void UpdateReactorDynamics()
        {
            var deltaTime = ServiceHolder<IWorldObjectManager>.Obj.TickDeltaTime;
            //! Thermal calcs
            float absorbtionHeat = freeNeutrons * this.P_absorbed * this.neutronAbsorbtionHeat;
            this.coreHeat += absorbtionHeat;

            float coreCasingHeatFlux = (this.coreTemperature - this.casingTemperature) * this.coreCasingTC;
            float casingEnvHeatFlux = (this.casingTemperature - 20) * this.casingEnvTC;

            float coolingHeat = 0;
            foreach (float cooling in coolingQueue) coolingHeat += cooling;
            this.coolingQueue.Clear();

            this.coreHeat -= coreCasingHeatFlux;
            this.casingHeat += coreCasingHeatFlux - casingEnvHeatFlux - coolingHeat;

            //! Nuclear Calcs
            if (this.Parent.GetComponent<ReactorFuelComponent>().HasFuel())
            {
                this.n_avg = 3;
                this.fuelNeutronEmmision = 500;
            }
            else
            {
                this.n_avg = 0;
                this.fuelNeutronEmmision = 0;
            }

            float rodInsertion = CalculateControlRodInsertion(this.targetNeutronRate, this.freeNeutrons);
            this.ControlRodInfoView = Localizer.Format("{0}%", (rodInsertion*100).ToString());
            float P_adj = (1 - rodInsertion);

            float freeNeutronsRate = CalculateFreeNeutronRate(this.freeNeutrons, P_adj);
            
            float fissionRate = this.freeNeutrons * (this.P_fission * (this.P_impact * P_adj));
            this.FissionRateView = Localizer.Format("{0} fission events per tick" , fissionRate);
            this.Parent.GetComponent<ReactorFuelComponent>().UseFuel(fissionRate * 0.000001f);

            //if (!this.steadyState) 
            if (this.freeNeutrons + freeNeutronsRate <= 0) this.freeNeutrons = 0;
            else this.freeNeutrons += freeNeutronsRate;

            this.CoreTemperatureView = Localizer.Format("{0} C, {1} J (+{2} J, -{3} J)", this.coreTemperature.ToString("0"), this.coreHeat.ToString("0"), absorbtionHeat.ToString("0.0"), coreCasingHeatFlux.ToString("0.0"));
            this.CasingTemperatureView = Localizer.Format("{0} C, {1} J (+{2} J, -{3} J, {4}% Eff)", this.casingTemperature.ToString("0"), this.casingHeat.ToString("0"), coreCasingHeatFlux.ToString("0.0"), (casingEnvHeatFlux + coolingHeat).ToString("0.0"), (100*coolingHeat/(coolingHeat+casingEnvHeatFlux)).ToString("0.0"));
            this.NeutronView = Localizer.Format("{0} Free neutrons", this.freeNeutrons.ToString("0"));
        }

        //--------------------------------------------------------------
        //!                UI STUFF BELOW THIS LINE
        //--------------------------------------------------------------


        [Eco, ClientInterfaceProperty, PropReadOnly, LocDisplayName("Core Temperature/Heat")]
        public string CoreTemperatureView { get; set; }

        [Eco, ClientInterfaceProperty, PropReadOnly, LocDisplayName("Casing Temperature/Heat")]
        public string CasingTemperatureView { get; set; }

        [Eco, ClientInterfaceProperty, PropReadOnly, LocDisplayName("Free Neutrons in Reactor vore")]
        public string NeutronView { get; set; }

        [Eco, ClientInterfaceProperty, PropReadOnly, LocDisplayName("Fission Rate")]
        public string FissionRateView { get; set; }

        [Eco, ClientInterfaceProperty, PropReadOnly, LocDisplayName("Control Rod Insertion")]
        public string ControlRodInfoView { get; set; }

        public float neutronRateView { get; set; }
        [Eco, ClientInterfaceProperty, NegativeAllowed, LocDisplayName("Set Desired Neutron Rate")]
        public float NeutronRateView
        {
            get => this.neutronRateView;
            set
            {
                if (value == this.neutronRateView) return;
                this.neutronRateView = value;
                this.Changed(nameof(this.NeutronRateView));
            }
        }

        [RPC, Autogen]
        public virtual void SetControlRod(Player player) 
        {
            this.targetNeutronRate = this.neutronRateView;
        }

        public float coolantFlowRate { get; set; }
        [Eco, ClientInterfaceProperty, NegativeAllowed]
        public float CoolantFlowRate
        {
            get => this.coolantFlowRate;
            set
            {
                if (value == this.coolantFlowRate) return;
                this.coolantFlowRate = value;
                this.Changed(nameof(this.CoolantFlowRate));
                if (this?.Parent?.GetComponent<DigiCustomLiquidConverterComponent>() != null)
                {
                    this.Parent.GetComponent<DigiCustomLiquidConverterComponent>().consumer.constantConsumptionRate = value;
                }   
            }
        }
    }
}
